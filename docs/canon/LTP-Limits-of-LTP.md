# Limits of LTP

## Why this page exists
LTP is often misunderstood when approached as a framework, model, or decision system.
This page clarifies what LTP intentionally does **not** attempt to solve.

Defining limits is not a weakness.
For protocols, it is a form of strength and long-term stability.

## Core principle
LTP defines **orientation**, not outcomes.
It does not decide what should happen.
It ensures that whatever happens remains coherent over time.

## What LTP is not

### 1) Not a decision-making system
LTP never chooses actions, answers, or policies.
It does not:
- rank options
- select a “best” response
- optimize for reward, accuracy, or utility

All decisions happen outside the protocol.

### 2) Not a model or inference engine
LTP does not:
- generate tokens
- run neural networks
- perform attention or prediction

It is model-agnostic by design.
Different models may enter and exit the same continuity thread without breaking orientation.

### 3) Not memory in the traditional sense
LTP does not store knowledge, facts, or embeddings.
Instead, it preserves:
- trajectory
- constraints
- admissible transitions

Memory answers *what is known*.  
Orientation answers *where we are*.

### 4) Not an orchestration framework
LTP does not:
- manage workflows
- schedule tasks
- coordinate services

It can be used alongside orchestration systems, but never replaces them.

### 5) Not an optimization layer
LTP does not aim to:
- reduce latency
- minimize tokens
- maximize throughput

Those concerns belong to execution layers.
LTP operates **before execution**, at the level of permission and readiness.

## Why these limits matter
Most system failures come from scope creep, not lack of features.
By refusing to:
- decide
- predict
- optimize
- orchestrate

LTP remains:
- auditable
- explainable
- reusable across domains
- stable across decades, not versions

## Relationship to other layers

| Layer | Responsibility |
|------|----------------|
| Models | Prediction & generation |
| Agents | Decision logic |
| Orchestration | Execution & scheduling |
| LTP | Continuity & orientation |

LTP does not compete with these layers. It aligns them.

## Final note
If you are looking for:
- smarter decisions → use better models
- faster execution → optimize infrastructure
- richer memory → build knowledge systems

If you are losing:
- context after retries
- meaning across restarts
- coherence across models

Then LTP is the missing layer.
